---
layout:     post
title:      "时间&时钟学习笔记"
autor:      "dusmart"
tags:
    - notes
---

> 某一天在听系统组件吹极高可用时，听到对于不同节点写入的冲突数据的合并的处理逻辑，采用了LWW方法(后写入者胜)，于是有人在问分布式场景下的时间先后顺序是怎么处理的，接着就是一堆难以理解的名词，NTP、HLC，这些都是些什么东东？

<!--more-->

# 关于时间

基本上所有介绍混合逻辑时钟（HLC hybrid logic clock）的博客，都会先讲物理时钟（PT physical time）、逻辑时钟（LC logic clock）、向量时钟（VC vector clock）、真实时钟（TT true time）。



但提到我们生活中的时间，则绕不开格林威治平均时间（GMT）, 协调世界时间（UTC）, 夏令时（DST）等各种时间标准。



所以我们谈到时间的时候到底是想描述什么，其实无论是在分布式系统中还是生活中我们其实只是想衡量一些事件发生的绝对先后顺序以及先后间隔的比例，在分布式系统中更关心前者，从而可以让不同节点间达成一致。



在牛顿建立的经典物理体系下，是存在绝对参考系、绝对空间和绝对时间的，绝对时间不会随着任何外部的作用或观察者改变。通过定义一个绝对时间的时间起点和一个标准时间间隔（例如以伦敦格林威治的子午线为基线，以地球自转为标准得到GMT），我们就可以得到GMT时间标准下任何一个事件发生的准确时刻。



基于狭义相对论，如果承认“真空光速独立于参考系”这一实验事实为基本原理，可以建立起一种新的时空观。**当物体运动时，它的一切（物理、化学变化）从参照系的角度来看都会变慢，就是**[钟慢效应](https://zh.wikipedia.org/wiki/時間膨脹)。这里不得不提到双生子佯谬。

## 双生子佯谬

设想有两个孪生兄弟甲和乙，甲乘飞船作太空旅行，乙留在地面等待甲。甲所乘坐的飞船在极短的时间内加速。然后飞船以速度v作匀速直线飞行，飞船飞行很长一段时间后，迅速调头并继续以速度v作匀速直线飞行。回到地面时紧急减速、降落，并与一直在地面上的乙会合。如果不考虑加速减速的过程，两者在自己的参考系都会认为对方比自己年轻！



这显然是不可能的，矛盾的点恰恰在于钟慢效应只是对于惯性参考系而言的，但飞船加速的过程受到了非惯性的力，因此需要其他计算方式，而不能以飞船为参考系直接套用钟慢效应。

# 时间标准

## [GMT](https://zh.wikipedia.org/wiki/格林尼治標準時間) **格林尼治平均时间**

> 1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。

**参考时间点**：[平太阳](https://zh.wikipedia.org/wiki/平太阳)横穿格林尼治子午线时为正午

**时间间隔标准**：地球自转一圈为一天

**缺陷**：地球自转时间间隔不规则，逐渐减速，目前已被UTC替代

## [UTC](https://zh.wikipedia.org/wiki/协调世界时) **协调世界时**

> 正式形成于1963年[国际无线电咨询委员会](https://zh.wikipedia.org/wiki/国际无线电咨询委员会)的374号建议中，被应用于许多[互联网](https://zh.wikipedia.org/wiki/互联网)和[万维网](https://zh.wikipedia.org/wiki/万维网)的标准中

**参考时间点**：GMT

**时间间隔标准**：一秒为铯-133[原子](https://zh.wikipedia.org/wiki/原子)[基态](https://zh.wikipedia.org/wiki/基态)两个超精细能级间[跃迁](https://zh.wikipedia.org/wiki/跃迁)辐射振荡9,192,631,770周所持续的时间

**特殊规则**：不规则的加入闰秒来抵消地球自转变慢的影响，保持和世界时（UT 也以自转为标准的时间）之间的差距不至于过大，因为自转速率不好预测，会提前6个月发布闰秒的插入决定，目前还没遇到过自转过快导致的闰秒。

## [DST](https://zh.wikipedia.org/wiki/夏时制) 夏令时

> 是一种在[夏季](https://zh.wikipedia.org/wiki/夏季)月份牺牲正常的日出时间，而将时间调快的做法。

**参考时间点**：UTC

**时间间隔标准**：UTC

**特殊规则**：各国或地区标准不一致；但都是在春季调快时钟会减少当日的时长，而在秋季调慢时钟增加当日的时长。如果在春季的午夜时分调快1小时，以数字显示的本地时间将会从11:59:59.9跳至01:00:00.0。

![img](/assets/img/2021-01-08/3d652e01-0116-47ec-ac9c-524046cf662b.png)

怎么会有这种奇葩的时间标准！！！！！！

# 分布式系统中的时钟

## Happen Before 关系

对于两个事件A和B，这两个事件可以在不同的线程/机器中执行。如果A Happens-Before B，那么可以保证，当A执行完后，A的执行结果对B是可见的。

和所有其他严格偏序关系一样，hanppen before 关系是*[传递](https://en.wikipedia.org/wiki/Transitive_relation)*，不*[自反](https://en.wikipedia.org/wiki/Irreflexive_relation)*和[反对称的](https://en.wikipedia.org/wiki/Antisymmetric_relation)。

这个概念不止出现在分布式系统的时钟概念中，也出现于各种语言的并发模型中，如 GO Memory Model 和 Java Memory Model。

1. 在同一个协程内部，存在一定的happen before关系（如先写后读，写完成 happen before 读）。对代码 a=1;b=2; 观测到的执行顺序一定是 a 先赋值，b 后赋值，即 a=1 hanppen before b=2。但这并不保证在另一个协程内观测到的顺序也是这样【缓存、重排等等】。
2. 在同一个管道中，发送事件 happen before 对应数据的接收完成事件
3. 对于容量为 C 的管道，第 k 个接收者接收的事件 happen before 第 k+C 个写入的完成事件。
   1. 对于无缓冲的管道，接收者的接收事件 happen before 写入完成事件
4. 对于 Lock 来说，对于任意的 *n < m，*第 n 次 UnLock happen before 第 m 次 Lock 完成
5. 对于读写锁、Once、协程创建等等都定义了其 happen before 关系

通过 happen before 关系的传递性，我们就可以保证不同协程间的 happend before 关系，从而来保证从每一个协程中观测，对于一个关键变量的读取一定在他写入完成之后。



## PT 物理时钟

物理时钟即机器本地的时钟，而由于设备硬件不同，本身存在偏差，一天的误差可能有毫秒甚至秒级，所以需要对不同的机器时钟进行同步使得机器的时间进行相对统一。NTP是目前比较常用的同步时间的方式，其机制为CS架构，每台机器上存在一个NTP的客户端，与NTP的服务端进行同步，校准本地的时间。

## LC 逻辑时钟

逻辑时钟只关心偏序关系【hanppen before】，不关心时间间隔

- 同一进程上发生的事件，不考虑并发，根据该进程的本机时钟，后者b比前者a靠后则 LC(a) < LC(b)
- 不同实例通信时的发送事件a和接收时间b，接收时间b比发送事件a靠后，即 LC(a) < LC(b)

![img](/assets/img/2021-01-08/8d4fbf24-073c-4076-a42c-a4e444ea6efb.png)



这样通过每个实例自身的一个计数器，我们就可以确定分布式系统上的一个严格偏序关系

- 如果a 发生在 b 之前，那么一定有LC(a) < LC(b)
- 但反之不一定。

*考虑 A1 和 C2，LC(A2) < LC(C2)，但两者是并发进行的，我们无法判断是 C2 的确是 A1 后发生的还是两者并发进行，因此 LC 无法很好的区分并发和先后关系。*

## VC 向量时钟

向量时钟是通过引入更多的存储来表示时钟，可以更好区分出先后关系和并发关系

对于任意一个进程：

- VCi[i]表示进程i上面事件发生的个数。
- VCi[j]表示进程i知道的j进程上面发生的事件发生数，即进程i对进程j的认知。

向量更新算法： 

1. 进程i每次发生1个事件，VCi[i] = VCi[i]+1 
2. 当进程i发送消息给进程j时，携带进程i的信息VCi整个向量时钟（进程i对全局的认知）。
3. 当进程j收到进程i时，更新自己的VCj[k]=max{VCi[k], VCj[k]}, k从1-n，即向量内部所有维度都需要更新。

![img](/assets/img/2021-01-08/3b4fcf0d-1b16-48ef-b192-9a68e1c9c69f.png)



假设有事件 a、b 分别在节点 P、Q 上发生，向量时钟分别为 Ta、Tb

- Tb[Q] > Ta[Q] 并且 Tb[P] >= Ta[P]，则 a 发生于 b 之前
- 反之，如果 Tb[Q] > Ta[Q] 并且 Tb[P] < Ta[P]，则认为a、b同时发生，记作 a <-> b。

*例如上图中节点 B 上的第 4 个事件 (A:2，B:4，C:1) 与节点 C 上的第 2 个事件 (B:3，C:2) 没有因果关系，属于同时发生事件。*



###### 其他相关资料

[Dynamo: Amazon’s Highly Available Key-value Store ](http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf) 一文提出了向量时钟

[why-cassandra-doesnt-need-vector-clocks](https://www.datastax.com/blog/why-cassandra-doesnt-need-vector-clocks) 一文描述了使用了向量时钟的Dynamo的三个问题

1. 性能问题：每更新一次，都需要把所有字段读出来反序列化，更新某字段，序列化，再存入数据库
2. 冲突导致难用：当检测到冲突后服务端会给一个key返回多个版本的val，让客户端决定如何处理（我们写业务的时候还要处理这？）Riak 早期实现倒是简单，直接LWW，丢数据就丢数据，who cares。
3. 另外还是冲突无法完全解决的问题：即使实现的再好，也无法获取所有的因果关系信息，所以后来 Cassandra和Riak都又加了计数器进去

[https://riak.com/why-vector-clocks-are-easy](https://riak.com/why-vector-clocks-are-easy/) 说了向量时钟很简单

https://riak.com/why-vector-clocks-are-hard/ 怼了之前说向量时钟容易的文章，主要就两点

1. what  an actor is (i.e. where the incrementing and resolution is, and what parties get their own field in the vector) 

为了避免时钟向量的长度越来越长，需要将每一个client映射到一个actor，如何选择这个actor？映射会导致必然的信息丢失（某些冲突无法解决）

1. how to keep vclocks from growing without bound over time.

随着client的增多，vclock一定会增长，某些做法是定时修剪向量的字段；会丢失部分信息，不会导致数据丢失，但实现也比较复杂

## TT 真实时钟

TT是google在Spanner系统中提出的，其原理是基于原子钟同步，通过时间戳层面实现全局统一，从而解决事件顺序的问题。

真实时钟是一个误差有界但非0的全局同步时钟：它返回的是一个ms级别的时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就认为是并发事件了。

- 缺点其一是由于依赖原子钟，普通系统没办法实现；人民币玩家
- 其二是假如要保证以后可以测出 e, f 事件的先后关系，f事件需要被delay一个小区间后再允许发生。

![img](/assets/img/2021-01-08/2cd32c0a-55ac-4041-a1f6-09d6b519b19a.png)



## HLC 混合逻辑时钟

混合逻辑时钟是2014年提出的，混合了物理时钟PT和逻辑时钟LC，是为了实现以下4个目标

1. 首先满足LC的因果一致性，a hb b => HLC(a) < HLC(b)
2. 其次单个时钟O(1)的存储空间（VC是O(n)，n为分布式系统下的节点个数）
3. 另外单个时钟的大小有确定的边界，不会无穷大 
4. 尽可能接近物理时钟PT，也就是说，HLC和PT的差值有个确定的边界。这条规则的好处是，只要两次操作间隔大于这个确定的边界，就可以推断出先后关系，无论事件是否是当前分布式系统内的。

#### 一个朴素的算法

![img](/assets/img/2021-01-08/56878940-5a95-4fe6-b1b3-8a822b0c3b81.png)



- 初始时 l.j = 0，大家的初始HLC时钟都是 0
- 发送事件/本地事件时，l.j = max(l.j+1, pt.j)
  - 事件的时间一定要比本机上一个事件大
- 也不小于本机时间戳
- 接收事件时，l.j = max(l.j+1, l.m+1, pt.j)
  - 接收事件的时间要比本机上一个事件大
- 比消息发送时间大

#### 加上限制条件

显然这样下去，会导致 l.j 越来越大，完全用不到 pt.j 了，也就是 HLC 时间和真实时间完全没法比，无法达成目标3和目标4

**那如果要求单个进程内的事件发生的间隔必须大于物理时钟的一定间隔呢？**

我们假设可以要求每秒钟内能发生的事件数目小于 2^16，那么一个 64 位的数字，前 48 位存储秒级时间戳戳戳有余，后面的 16 位存储一个计数器。·

![img](/assets/img/2021-01-08/e4a26e75-08e4-423d-90ec-0073cd77425b.png)



- 初始时：大家的时钟都是 0，计数器也是 0
- 发送事件/本地事件时：
  - 时间肯定要不小于上一个事件的时间戳
- 时间也不小于本机时间戳
- 如果和上一个事件的时间戳一样，那么计数器上要大一些，否则计数器可以清零了
- 接受事件时：
  - 时间肯定要不小于上一个事件、本机事件、发送事件的时间戳
- 如果和上一个事件时间一样，和消息时间一样，那么计数器要比他们的计数器都大一些
- 否则如果还是有时间一样的，只要比其中一个人的计数器大一些就可以了
- 否则计数器没用了，可以清零



# NTP 网络时间协议

> *Network Time Protocol*

采用UTC标准，是用来使计算机[时间同步](https://baike.baidu.com/item/时间同步)化的一种协议，它可以使[计算机](https://baike.baidu.com/item/计算机/140338)对其[服务器](https://baike.baidu.com/item/服务器/100571)或[时钟源](https://baike.baidu.com/item/时钟源/3219811)（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的[协议](https://baike.baidu.com/item/协议/670528)攻击。



还有一些其他的更精确的时间同步算法如**PTP、SyncE**

#### 基本原理

服务器和客户端之间通过二次报文交换，确定主从时间误差，客户端校准本地计算机时间，完成时间同步，有条件的话进一步校准本地时钟频率。

![img](/assets/img/2021-01-08/425ab9b5-45c7-4450-8d8e-e15c81151b49.png)



Sigma = (t4-t1)-(t3-t2)

假设来回网络链路是对称的，即传输时延相等，那么可以计算客户端与服务器之间的时间误差Delta为：

Delta = t2-t1-Sigma/2=((t2-t1)+(t3-t4))/2

Delta = t3-t4+Sigma/2= ((t2-t1)+(t3-t4))/2

客户端修正自身的物理时钟，增加 Delta 即可 

对闰秒的处理有特殊协议

#### 误差来源

- 网络不对称
- 打时间戳的位置在应用层，而非链路层

一般来说误差都在 5ms 以内

# 时钟回退

> 闰秒回退或本机时钟不准，导致 NTP 矫正回退

![img](/assets/img/2021-01-08/a002e2a6-1414-46af-b62d-0d74d18d7fe8.png)



时钟回退有两种

1. 退出所有程序->NTP 矫正->等时间赶上退出程序前的时刻->恢复所有程序
2. 在程序运行时直接进行 NTP 矫正

如果雪花算法或者HLC算法运行中遇到了时间回退，我们该怎么办？

HLC 算法遇到时钟回退的效果是计数器可能会被用尽导致事件的时钟不得不加一，即一段时间内和物理时钟存在偏差，长远来看并不会影响HLC达成的目标。



雪花算法解决时钟回退（timestamp:workerId:counter）

1. 抛出异常拒绝服务
2. 内存中保存一段时间内的每个时刻的计数器最大值，每次产生id时，先查询是否发生了回退，如果回退范围在我们允许的这段范围内，则使用此时回退的时刻的计数器最大值接着发号，否则报错
3. 每个机器分配多个备用的workerId，每个workerId生效期间记录其对应的最大发号时间戳，在发生回拨后检查是否有可用的workerId，如果没有则拒绝服务，否则切换一个workerId并记录其最大发号时间戳
4. 将id分配更改为生产着消费者模式，一个专门负责生产id的线程在可用id少于50%后开始分配id，当发现时钟回退后接着使用上一次的时间戳分配，计数器满后再推进时间戳，直到物理时钟追上后再使用物理时钟







# 参考链接

https://flashgene.com/archives/30345.html

http://melanx.com/2018/12/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E9%92%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F/

https://ying-zhang.github.io/yi/2017/x-spanner-truetime-cap/

https://tech.bytedance.net/articles/6839146494709202958

https://segmentfault.com/a/1190000005337116
