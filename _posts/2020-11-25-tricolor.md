---
layout:     post
title:      "三色标记算法学习笔记"
autor:      "dusmart"
tags:
    - notes
---

# 垃圾回收算法

垃圾回收追踪主要分为两种收集方法，分别是引用计数收集和追踪收集；常见的算法有

|                                                                        |                                                                                                                                                                                                               |                                                             |
| ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| 算法                                                                     | 核心实现                                                                                                                                                                                                          | 优劣                                                          |
| 引用计数法【引用计数】                                                            | 对每一个对象维护一个被引用的数目，每次新增或取消引用时增减该数目，当数目为0时回收                                                                                                                                                                     | 优势：可即刻回收垃圾，不需要暂停程序劣势：额外占用存储空间，无法处理环装引用（可能会有各种相关算法来优化、比如弱引用） |
| 标记-清除【追踪收集】                                                            | 先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后，恢复运行线程。                                                                                                                                                      | 劣势：产生大量的空闲空间碎片                                              |
| 标记-压缩【追踪收集】                                                            | 主要实现同上，但回收期间同时会将保留的存储对象搬运汇集到连续的内存空间。有[Two-Finger算法](https://www.cnblogs.com/Leon-The-Professional/p/9994395.html#two-finger算法)，[表格算法](https://www.cnblogs.com/Leon-The-Professional/p/9994395.html#表格算法) 等实现。 | 优势：碎片较少                                                     |
| [复制](https://blog.csdn.net/linsongbin1/article/details/51668859)【追踪收集】 | 将内存分为两个区域，主要实现同上，但回收期间会将保留对象从一个分区搬到另一个分区。一般用于分代算法的新生代。                                                                                                                                                        | 优势：碎片更少劣势：浪费了一半的空间；如果存活量大(数量\*大小)、复制性能差                     |
| [分代](https://segmentfault.com/a/1190000023379683)【追踪收集】                | 需要将内存空间分成若干年轻代空间和年老代空间。新对象会先存放在年轻代分区，年轻代分区会较为频密进行较为激进垃圾回收行为，每次幸存的者寿命加一。寿命到达阈值或占用空间超过阈值时，则被移动到年老代空间，年老代空间会较少运行垃圾回收行为。                                                                                          | 优势：对对象进行分代，回收效率更高                                           |

三色标记法属于追踪收集类算法，核心思想同样是通过分析某些“根”对象的引用关系，来确定需要保留的可访问对象。

![](/assets/img/2020-11-25/1606476860248_077ba6976ab51a5036be6acfd7c3caca.jpg)

<!--more-->

# 三色标记算法

## 选择三色标记的原因

标记清扫算法是严格按照追踪式算法的思路来实现的，会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是 0，如果发现对象是可达的就会置为 1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未被标记的对象统一清理。标记是单独存储在一块空闲区域的。

****

![](/assets/img/2020-11-25/1606476860473_18defbd05ce6696c1355dc7de069de1d.jpg)

[标记清除算法示意图](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Naïve_mark-and-sweep)【 go1.3之前的算法】

![](/assets/img/2020-11-25/1606476860278_f9221681e4ce599f5c0ad8f4e3c9ee34.jpg)

**go1.3之前版本的STW范围**

![](/assets/img/2020-11-25/1606476860224_6a56563f235b385b40cb0292bfba77be.jpg)

**\[go1.3, go1.5) 版本的STW范围**

这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 GC 运行时程序长时间挂起的问题，Golang 就选择了不必整个过程都完全暂停的三色标记法。

****

![](/assets/img/2020-11-25/1606476860352_5fe8ea45e2518ca19cfeb31558160fb1.jpg)

[三色标记示意图](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep)

## 需要STW的三色标记流程示意图

先不去了解三色标记的精确定义，我们来看一遍带Stop-The-World过程的三色标记流程，直观感受一下三色变化。

![](/assets/img/2020-11-25/1606476860226_9e8c23b16593faa5b037657a67cb0183.jpg)

![](/assets/img/2020-11-25/1606476860235_0d6e1dbb548e8280c7f2bec6377c83ff.jpg)

![](/assets/img/2020-11-25/1606476860418_856be166579b57b17860c3c855eb5331.jpg)

![](/assets/img/2020-11-25/1606476860310_a12e7f4cea03d61a3645427562243475.jpg)

![](/assets/img/2020-11-25/1606476860281_a9c4721f46f9fb3567b2cd0ecd7c3453.jpg)

![](/assets/img/2020-11-25/1606476860451_be6d3b0bb14719b0dfdcaabaebbd8a06.jpg)

![](/assets/img/2020-11-25/1606476860271_2914047aa17781d64650e42e031710e8.jpg)

## 带屏障的三色标记

> 所有根对象可达对象，最终一定不是白色！

### 三色标记的基础

#### 三色集合的定义

* 白色集合：

  * 表明没有被 collector 访问到
  * 如果在本轮遍历结束时还是白色，那么就会被收回

* 黑色集合：

  * 表明对象被 collector 访问过，且子节点被 scan 到了或终将会被 scan 到，属于可到达对象
  * 也就要求对于其指向的白色对象，一定要有其他灰色对象直接/间接指着。【并发情况下才会出现黑色直接引用白色，带STW的过程不会出现】

* 灰色集合：

  * 表明对象被访问过，但是它的子节点还没有被 scan 到

#### 错误回收的前提

仔细思考，发现如果要让 collector 错误的回收可达对象，需要同时满足以下两点

1. 把指向白色对象的指针存储到一黑色对象中 

   1. 黑色已经被访问过，他的子节点已被 collector 处理
   2. 这会导致这个白色对象无法从这个黑色节点那里开始被 collector 处理

2. 在 collector 访问该白色对象之前，破坏指向它的原有指针

   1. 破坏上游灰色对象到该白色对象之间的指针
   2. 这会导致这个白色对象无法再从其他渠道被 collector 处理

#### 阻止错误回收的不变式

为了破坏以上两点，只要满足以下任意一个不变式即可

强三色不变式：以上两点都被破坏，黑色不能直接引用白色

弱三色不变式：仅第二点被破坏

![](/assets/img/2020-11-25/1606476860411_8730c7363216da637e099a123d005680.jpg)

![](/assets/img/2020-11-25/1606476860337_db4f51c88bf80320b31ad37419dadbbe.jpg)

### 插入屏障

> 将 B 挂在 A 下游，B 必须被标记为灰色；

```
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(ptr) // 将新增的引用对象标记为灰色
    *slot = ptr
}
这样可以保证满足强三色不变式，因为肯定无法新增黑色对白色的引用。
```

\[go1.5, go1.8) 针对堆上的新增对象采用这种方式，对于栈上的新增对象选择了再次STW的三色标记。

1. 由于插入屏障的“保守”，在一次回收过程中很可能会残留一部分对象没有回收成功，只有在下一个回收过程中才会被回收；
2. 在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销；为了避免造成性能问题，Go 团队在最终实现时，没有为所有栈上的指针写操作，启用写屏障，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了灰色赋值器，将会需要标记终止阶段 STW 时对这些栈进行重新扫描。

#### Golang 版本的插入屏障阻止错误回收示意图

![](/assets/img/2020-11-25/1606476860297_c54045718a23eecf11b1db593542cbe3.jpg)

![](/assets/img/2020-11-25/1606476860458_bdec8f20946399465710235d3fccd6b7.jpg)

![](/assets/img/2020-11-25/1606476860416_8d8bea10e976a7f6f94738f6298af7c3.jpg)

![](/assets/img/2020-11-25/1606476860381_aa95b103442b801fa8af572dd85ad445.jpg)

![](/assets/img/2020-11-25/1606476860456_3df85459343937da178bb051dc5428c9.jpg)

![](/assets/img/2020-11-25/1606476860460_7775418abb9746cabe7130693a6c24ad.jpg)

![](/assets/img/2020-11-25/1606476860344_6265b398c3b5d7b161f655e795779d2b.jpg)

![](/assets/img/2020-11-25/1606476860276_aa724c82ae8b3503f751dfee4f2544c6.jpg)

![](/assets/img/2020-11-25/1606476860291_f77e4a5cff144186ad0a6cecf3591a5c.jpg)

![](/assets/img/2020-11-25/1606476860259_ef0caab57dbfc6f72388361c2337dd04.jpg)

### 删除屏障

> 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

```
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot) // 将原来位置被删除引用的对象标位灰色
    *slot = ptr
}
这样可以保证满足弱三色不变式
```

* 白色对象没有增多，不会新增黑色对白色的引用
* 只需要证明原有白色对象上游可达到灰色的链条没断
* 本次删除可能造成白色对象上游可达灰色链条断裂的只有两种

1. 1. A 灰色 -> B 白色，   A->B 断裂
   2. D 灰色 -> E 白色 -> F 白色，    E->F 断裂

* 但我们在断裂后，分别将 B 和 F 分别置为了灰色，所以 B 和 E 下游的白色依旧可以向上到达灰色，对于 B 和 E 本身而言，B 自身灰色了所以不影响弱三色不变式，E 的上游结构未变，所以也不影响弱三色不变式

1. 缺陷是删除屏障会拦截写操作，进而导致波面的退后，产生“冗余”的扫描

![](/assets/img/2020-11-25/1606476860233_a328e571f5c45113811b4bae456903a5.jpg)

go 没有单纯采用这种方式的版本，因此不举例了，脑补一下

### 混合写屏障

> 1、GC 开始将栈上的对象全部扫描并标记为黑色。

> 2、GC 期间，任何在栈上创建的新对象，均为黑色。

> 3、被删除的对象标记为灰色。

> 4、被添加的对象标记为灰色。

```
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot) // 仅对堆对象生效
    shade(ptr) // 仅对堆对象生效
    *slot = ptr
}
Go 在 1.8 的时候为了简化 GC 的流程，同时减少标记终止阶段的重扫成本，将插入屏障和删除屏障进行混合，形成混合写屏障。
```

#### 混合写屏障开始时的流程

![](/assets/img/2020-11-25/1606476860286_81acb7dc3a540513aff280b25043178a.jpg)

![](/assets/img/2020-11-25/1606476860334_208fa2c7114fbba75eef0ba83e3c7805.jpg)

#### 混合写屏障过程流程举例【 堆对象的下游变更为栈对象的下游】

> 某个堆对象的下游变更为栈对象的下游，堆区混合写屏障的**删除屏障**保护了下游

```
// a, b, c 为栈对象
// x, y, z 为堆对象
// GC前的关系
a.next = b
x.next = y
// GC中的变更
a.next = y
x.next = nil
```

![](/assets/img/2020-11-25/1606476860313_1b93aa16681c1430596cf92ff5b965b6.jpg)

#### 混合写屏障过程流程举例【栈内的引用变更】

> 栈内的引用变更，栈区混合写屏障的**栈内强制黑色**保护了下游

```
// a, b, c 为栈对象
// GC前的关系
a.next = b
c
// GC中的变更
c.next = b
a.next = nil
```

![](/assets/img/2020-11-25/1606476860515_0156e428d918e542267e6aaaeaf8d9e8.jpg)

![](/assets/img/2020-11-25/1606476860316_2df19de4ce0ba34676069131dd6fe97e.jpg)

#### 混合写屏障过程流程举例【堆内的引用变更】

> 堆内的引用变更，堆区混合写屏障的**删除屏障和插入屏障**保护了下游 （两次变色，有性能损耗）

```
// x, y, z 为堆对象
// GC前的关系
x.next = y
z
// GC中的变更
z.next = y
x.next = nil
```

![](/assets/img/2020-11-25/1606476860264_59cc4e860f059a978548b2f3da104d25.jpg)

![](/assets/img/2020-11-25/1606476860350_14af319e41547512d48f4842ccbeeac1.jpg)

#### 混合写屏障过程流程举例【栈对象的下游变更为堆对象的下游】

> 某个栈对象的下游变更为堆对象的下游，堆区混合写屏障的**删除屏障**冗余保护了下游

> `// a, b, c 为栈对象`

> `// x, y, z 为堆对象`

> `// GC前的关系`

> `a.next = b`

> `x.next = y`

> `// GC中的变更`

> `x.next = b`

![](/assets/img/2020-11-25/1606476860500_921405e1803d17d78ad5843f7df3d5b1.jpg)

![](/assets/img/2020-11-25/1606476860504_a8e04126009a1ef192c859cdb423f88e.jpg)

![](/assets/img/2020-11-25/1606476860268_1f7033ffdd2ccb92f475376c4e852c13.jpg)

### 最新版本的 (go1.14) 的三色标记抽象过程

1. gcinit 是属于 runtime 初始化中的 schedinit 的部分。在这一部分，会初始化一些参数，包括了读取环境变量 GOGC，来判断是否开启 GC 以及 GC 的触发条件（触发时的最小堆大小 && 堆增长比例）。
2. gcenable 是属于 runtime 本身的 main 函数内部的一部分，在 runtime 一系列初始化完成之后，`doInit(&runtime_inittask)` 方法之后，在 `doInit(&main_inittask)` 方法之前，即用户的程序刚刚要开始运行之前进行的。这个方法会在后台启动两个清扫相关的协程。（一个是清扫垃圾，一个是控制RSS——是否归还给系统）

当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：

|                  |                               |       |
| ---------------- | ----------------------------- | ----- |
| 阶段               | 说明                            | 状态 |
| SweepTermination | 清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障 | STW   |
| Mark             | 扫描标记阶段，与赋值器并发执行，写屏障开启         | 并发    |
| MarkTermination  | 标记终止阶段，保证一个周期内标记任务完成，停止写屏障    | STW   |
| GCoff            | 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭    | 并发    |
| GCoff            | 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭    | 并发    |

![](/assets/img/2020-11-25/1606476860228_e9a35f3e833917408e6a2918d88dcd20.jpg)

# 参考文档

<https://zh.wikipedia.org/wiki/%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6_(%e8%a8%88%e7%ae%97%e6%a9%9f%e7%a7%91%e5%ad%b8)>

<https://www.yuque.com/kshare/2020/cf544875-0900-40e4-9a6a-736b2a0b9356>

<https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.9.GC-GC.md>

<https://liujiacai.net/blog/2018/08/04/incremental-gc/>

<https://golang.org/src/runtime/mgc.go>

<https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/init/>
